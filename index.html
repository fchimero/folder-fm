<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="theme-color" content="#0a0a0a">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Folder.fm">
<meta name="description" content="An album-first local music player">
<link rel="manifest" href="manifest.webmanifest">
<link rel="apple-touch-icon" href="icon-192.svg">
<title></title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0a0a0a;
    --surface: #161616;
    --surface2: #111;
    --border: rgba(255,255,255,0.08);
    --text: #eee;
    --muted: #777;
    --accent: #eee;
    --font-body: system-ui, sans-serif;
    --font-title: system-ui, sans-serif;
    --player-h: 64px;
    --font-base: 12px;
    --font-sm: 11px;
    /* Safe area insets for notch/home-bar devices */
    --safe-top: env(safe-area-inset-top, 0px);
    --safe-bottom: env(safe-area-inset-bottom, 0px);
    --safe-left: env(safe-area-inset-left, 0px);
    --safe-right: env(safe-area-inset-right, 0px);
  }

  html, body {
    height: 100%;
    background: var(--bg);
    color: var(--text);
    font-family: var(--font-body);
    overflow-x: hidden;
    /* Prevent overscroll bounce on iOS */
    overscroll-behavior: none;
  }

  /* open-btn still used inside player empty state */
  .open-btn {
    background: none;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-size: var(--font-base);
    padding: 0.6rem 1.4rem;
    cursor: pointer;
    transition: all 0.2s;
    min-height: 44px;
    white-space: nowrap;
    font-family: inherit;
  }

  .open-btn:hover, .open-btn:focus-visible {
    background: var(--accent);
    color: var(--bg);
    outline: none;
  }

  /* ── PWA install banner ── */
  #install-banner {
    display: none;
    align-items: center;
    gap: 1rem;
    padding: 0.7rem 2rem;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    font-size: var(--font-base);
    color: var(--muted);
  }

  #install-banner span { flex: 1; }

  .install-btn {
    background: var(--accent);
    border: none;
    color: var(--bg);
    font-size: var(--font-base);
    padding: 0.4rem 1rem;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .install-btn:hover { opacity: 0.85; }

  .dismiss-btn {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    font-size: var(--font-base);
    line-height: 1;
    padding: 0.2rem;
  }

  /* ── Main content ── */
  main {
    padding: 2.5rem 3rem;
    padding-top: calc(2.5rem + var(--safe-top));
    padding-left: calc(3rem + var(--safe-left));
    padding-right: calc(3rem + var(--safe-right));
    padding-bottom: calc(var(--player-h) + 8rem + var(--safe-bottom));
    min-height: 100vh;
  }

  /* ── Empty state ── */
  #empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 60vh;
    gap: 1rem;
    text-align: center;
  }

  .empty-icon {
    font-size: 5rem;
    opacity: 0.15;
    line-height: 1;
  }

  .empty-title {
    font-size: 2rem;
    color: var(--muted);
  }

  .empty-sub {
    font-size: var(--font-base);
    color: var(--muted);
    opacity: 0.6;
    max-width: 280px;
    line-height: 1.8;
  }

  .pick-dir-btn {
    margin-top: 0.5rem;
    padding: 0.55rem 1.4rem;
    background: none;
    border: 1px solid var(--accent);
    border-radius: 999px;
    color: var(--accent);
    font: inherit;
    font-size: var(--font-base);
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
    -webkit-tap-highlight-color: transparent;
  }
  .pick-dir-btn:hover, .pick-dir-btn:focus-visible {
    background: var(--accent);
    color: #0a0a0a;
    outline: none;
  }

  /* ── Albums grid ── */
  #albums-grid {
    display: none;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 1.5rem;
  }

  .album-card {
    cursor: pointer;
    position: relative;
    /* tap highlight on mobile */
    -webkit-tap-highlight-color: transparent;
  }

  .album-art-wrap {
    position: relative;
    aspect-ratio: 1;
    overflow: hidden;
    border-radius: 8px;
    background: var(--surface2);
  }

  .album-art-wrap img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: transform 0.4s cubic-bezier(0.25,0.46,0.45,0.94);
  }

  /* .album-card:hover .album-art-wrap img {
    transform: scale(1.06);
  } */

  .album-art-wrap .no-art {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3.5rem;
    color: var(--border);
    background: linear-gradient(135deg, var(--surface) 0%, var(--surface2) 100%);
  }

  .album-overlay {
    position: absolute;
    inset: 0;
    /* background: rgba(0,0,0,0.5); */
    display: flex;
    align-items: flex-end;
    justify-content: right;
    opacity: 0;
    transition: opacity 0.25s;
  }

  /* Show overlay on hover (desktop) or when playing (all) */
  .album-card:hover .album-overlay { opacity: 1; }
  /* .album-card.playing .album-overlay { opacity: 1; } */

  .play-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text);
    margin-right: 0.5rem;
    margin-bottom: 0.5rem;
    background-color: rgba(22,22,22, 0.8); /* Semi-transparent white */
    border: 0.5px solid rgba(255, 255, 255, 0.1); /* Subtle edge */
  }

  .play-icon svg { margin-top: 5px; }

  /* .album-card.playing .album-art-wrap::after {
    content: '';
    position: absolute;
    inset: 0;
    border: 1px solid var(--accent);
    pointer-events: none;
    z-index: 2;
    border-radius: 8px;
    content: '';
  } */

  /* Animated bars for playing card */
  .playing-indicator {
    display: none;
    gap: 3px;
    align-items: flex-end;
    height: 18px;
  }
  .album-card.playing .playing-indicator { display: flex; }
  .album-card.playing .play-icon-svg { display: none; }

  .bar {
    width: 3px;
    background: var(--accent);
    border-radius: 1px;
    animation: eq 0.8s ease-in-out infinite alternate;
    transform-origin: bottom center;
  }
  .bar:nth-child(1) { height: 8px;  animation-delay: 0s; }
  .bar:nth-child(2) { height: 14px; animation-delay: 0.15s; }
  .bar:nth-child(3) { height: 10px; animation-delay: 0.3s; }
  .bar:nth-child(4) { height: 16px; animation-delay: 0.1s; }

  @keyframes eq {
    from { transform: scaleY(0.4); }
    to   { transform: scaleY(1); }
  }

  .paused .bar { animation-play-state: paused; }

  .album-info { padding: 0.75rem 0 0; }

  .album-title {
    font-family: var(--font-title);
    font-size: var(--font-base);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.3;
  }

  .album-artist {
    font-size: var(--font-sm);
    margin-top: 0.15rem;
    color: var(--muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* ── Player bar — always visible ── */
  #player {
    position: fixed;
    bottom: 1rem;
    left: 1rem;
    right: 1rem;
    background: rgba(20,20,20,0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    align-items: stretch;
    z-index: 100;
    padding-bottom: var(--safe-bottom);
    padding-left: var(--safe-left);
    padding-right: var(--safe-right);
    max-width: 640px;
    margin-left: auto;
    margin-right: auto;
    border-radius: 80px;
  }


  /* Idle state: directory loaded but nothing playing yet */
  #player.idle .controls,
  #player.idle .player-art,
  #player.idle .player-track,
  #player.idle .player-progress {
    opacity: 0.3;
    pointer-events: none;
  }

  /* ── Ellipsis menu ── */
  .menu-anchor {
    position: relative;
    flex-shrink: 0;
  }

  .menu-popover {
    position: absolute;
    bottom: calc(100% + 8px);
    right: 0;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px 0;
    min-width: 200px;
    z-index: 200;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  }

  .menu-item {
    display: block;
    width: 100%;
    padding: 10px 16px;
    background: none;
    border: none;
    color: var(--text);
    font: inherit;
    font-size: var(--font-base);
    text-align: left;
    cursor: pointer;
    white-space: nowrap;
    -webkit-tap-highlight-color: transparent;
  }
  .menu-item:hover, .menu-item:focus-visible {
    background: rgba(255,255,255,0.06);
    outline: none;
  }

  /* ── Appearance modal ── */
  #appearance-modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.6);
    z-index: 300;
    align-items: center;
    justify-content: center;
  }
  #appearance-modal.open { display: flex; }

  .modal-content {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    width: 100%;
    max-width: 360px;
    margin: 1rem;
    overflow: hidden;
  }

  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
  }

  .modal-header-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text);
  }

  .modal-close {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    font-size: 18px;
    line-height: 1;
    padding: 4px;
    border-radius: 4px;
    transition: color 0.15s, background 0.15s;
  }
  .modal-close:hover { color: var(--text); background: rgba(255,255,255,0.06); }

  .modal-body { padding: 16px 20px 20px; }

  .modal-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    padding: 10px 0;
  }
  .modal-row + .modal-row {
    border-top: 1px solid var(--border);
  }

  .modal-label {
    font-size: var(--font-base);
    color: var(--muted);
    flex-shrink: 0;
  }

  .accent-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .accent-color-input {
    width: 28px;
    height: 28px;
    padding: 0;
    border: none;
    background: none;
    cursor: pointer;
    border-radius: 4px;
  }
  .accent-color-input::-webkit-color-swatch-wrapper { padding: 0; }
  .accent-color-input::-webkit-color-swatch { border: 1px solid var(--border); border-radius: 4px; }

  .accent-hex-input {
    width: 72px;
    padding: 4px 8px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-family: monospace;
    font-size: var(--font-sm);
    text-align: center;
  }
  .accent-hex-input:focus { outline: 1px solid var(--accent); }

  .modal-select {
    padding: 6px 10px;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font: inherit;
    font-size: var(--font-sm);
    cursor: pointer;
    max-width: 200px;
  }
  .modal-select:focus { outline: 1px solid var(--accent); }
  .modal-select option { background: var(--surface2); color: var(--text); }

  /* ── Toggle switch ── */
  .toggle {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 20px;
    cursor: pointer;
    flex-shrink: 0;
  }
  .toggle input { display: none; }
  .toggle-track {
    position: absolute;
    inset: 0;
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 10px;
    transition: background 0.2s;
  }
  .toggle-track::after {
    content: '';
    position: absolute;
    top: 2px;
    left: 2px;
    width: 14px;
    height: 14px;
    background: var(--muted);
    border-radius: 50%;
    transition: transform 0.2s, background 0.2s;
  }
  .toggle input:checked + .toggle-track { background: var(--accent); border-color: var(--accent); }
  .toggle input:checked + .toggle-track::after { transform: translateX(16px); background: var(--bg); }

  /* ── Album progress segments ── */
  .progress-segments {
    position: absolute;
    inset: 0;
    display: none;
    pointer-events: none;
  }
  .progress-bar-wrap.album-mode .progress-segments { display: block; }

  .segment-divider {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    background: var(--bg);
  }

  /* Progress bar — full width at top of player */
  .player-progress {
    width: 100%;
    padding-top: 0.25rem;
  }

  .progress-bar-wrap {
    width: 100%;
    height: 2px;
    background: var(--border);
    cursor: pointer;
    position: relative;
    border-radius: 1px;
  }

  .progress-bar-wrap:hover { height: 4px; margin-top: -2px; }

  .progress-fill {
    height: 100%;
    background: var(--accent);
    width: 0%;
    border-radius: 1px;
    pointer-events: none;
    transition: width 0.3s linear;
  }

  .progress-times {
    display: flex;
    justify-content: space-between;
    font-size: 0.55rem;
    color: var(--muted);
    margin-top: 0.35rem;
    display: none;
  }

  /* Player body row */
  .player-body {
    height: var(--player-h);
    display: flex;
    align-items: center;
    padding: 0 1rem;
    gap: 0.5rem;
  }

  .player-art {
    width: 48px;
    height: 48px;
    flex-shrink: 0;
    overflow: hidden;
    background: var(--surface2);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.4rem;
    color: var(--border);
    border-radius: 2px;
  }

  .player-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .player-track {
    flex: 1;
    min-width: 0;
    padding-left: 0.5rem;
  }

  .player-track-title {
    font-family: var(--font-title);
    font-size: var(--font-base);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: var(--text);
  }

  .player-track-album {
    font-size: var(--font-sm);
    margin-top: 0.15rem;
    margin-bottom: 0.25rem;
    color: var(--muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .controls {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    flex-shrink: 0;
    padding-right: 0.5rem;
  }

  .ctrl-btn {
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: color 0.15s, background 0.15s;
    -webkit-tap-highlight-color: transparent;
  }

  .ctrl-btn:hover, .ctrl-btn:focus-visible {
    color: var(--text);
    background: rgba(255,255,255,0.06);
    outline: none;
  }

  .ctrl-btn.play-pause {
    width: 44px;
    height: 44px;
    /* border: 2px solid var(--accent); */
    border-radius: 50%;
    background-color: var(--accent);
    color: var(--bg);
  }

  .ctrl-btn.play-pause:hover {
    background: var(--text);
    color: var(--bg);
  }

  /* ── Scan state ── */
  #scan-state {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 60vh;
    gap: 1rem;
    text-align: center;
  }

  .scan-spinner {
    width: 36px;
    height: 36px;
    border: 2px solid var(--border);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .scan-text {
    font-size: var(--font-base);
    color: var(--muted);
  }

  #scan-count {
    font-size: 1.5rem;
    color: var(--accent);
  }

  /* ── Album entrance animation ── */
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0); }
  }

  .album-card { animation: fadeUp 0.4s both; }

  /* ═══════════════════════════════════════════
     RESPONSIVE BREAKPOINTS
  ═══════════════════════════════════════════ */

  /* Tablet */
  @media (max-width: 768px) {
    main {
      padding: 1.5rem 1.5rem;
      padding-top: calc(1.5rem + var(--safe-top));
      padding-bottom: calc(var(--player-h) + 7rem + var(--safe-bottom));
    }

    #albums-grid {
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 1.25rem;
    }

    .player-body { padding: 0 1rem; gap: 0.75rem; }
    .player-progress { padding: 0 1rem; }
  }

  /* Mobile */
  @media (max-width: 480px) {
    main {
      padding: 1rem 1rem;
      padding-top: calc(1rem + var(--safe-top));
      padding-bottom: calc(var(--player-h) + 7rem + var(--safe-bottom));
    }

    #albums-grid {
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 0.75rem;
    }

    .album-info { padding-top: 0.5rem; }
    .album-title { font-size: var(--font-base); }

    /* On mobile: always show overlay so tapping is clear */
    .album-overlay { opacity: 0; }
    .album-card:active .album-overlay { opacity: 1; }

    .play-icon { width: 48px; height: 48px; }

    #player {
      flex-direction: column;
    }

    .player-body {
      height: auto;
      padding: 0.5rem 1rem 0.6rem;
      gap: 0.6rem;
    }

    .player-progress {
      padding: 0.75rem 1rem 0;
    }

    .player-art { width: 48px; height: 48px; font-size: 1.1rem; }
    .player-track-title { font-size: var(--font-base); }
    .player-track-album { font-size: var(--font-sm); }

    .ctrl-btn { width: 32px; height: 32px; }
    .ctrl-btn.play-pause { width: 40px; height: 40px; }

    .empty-title { font-size: 1.5rem; }
    .empty-icon { font-size: 3.5rem; }
  }

  /* Very small (320px) */
  @media (max-width: 360px) {
    #albums-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.6rem;
    }
  }

  /* Large screens — wider grid */
  @media (min-width: 1400px) {
    #albums-grid {
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    }

    main { padding: 2.5rem 4rem; padding-bottom: calc(var(--player-h) + 8rem); }
  }

  /* ── Offline indicator ── */
  #offline-toast {
    display: none;
    position: fixed;
    top: calc(1rem + var(--safe-top));
    right: 1rem;
    background: var(--surface);
    border: 1px solid var(--border);
    color: var(--muted);
    font-size: var(--font-base);
    padding: 0.5rem 1rem;
    z-index: 1000;
    animation: fadeUp 0.3s both;
  }
  #offline-toast.show { display: block; }
  .text-btn {
    background: none;
    border: none;
    color: var(--fg);
    cursor: pointer;
    font: inherit;
    padding: 0;
    text-decoration: underline;
    text-underline-offset: 2px;
  }
  .text-btn:hover { opacity: 0.7; }
</style>
</head>
<body>



<!-- PWA install prompt -->
<div id="install-banner">
  <span>Install as an app for the best experience</span>
  <button class="install-btn" id="install-btn">Install</button>
  <button class="dismiss-btn" id="dismiss-install" aria-label="Dismiss">✕</button>
</div>

<main>
  <div id="empty-state">
    <div class="empty-icon">◉</div>
    <div class="empty-title">No directory loaded</div>
    <div class="empty-sub">Open a folder containing your music.</div>
    <button class="pick-dir-btn" id="pick-dir-btn">Pick Directory</button>
  </div>

  <div id="scan-state">
    <div class="scan-spinner"></div>
    <div id="scan-count">0</div>
    <div class="scan-text">Scanning for albums…</div>
  </div>

  <div id="albums-grid"></div>
</main>

<!-- Player — always visible -->
<div id="player">
  <div id="player-inner" class="player-inner">

    <div class="player-body">
      <!-- Transport controls -->
      <div class="controls">
        <button class="ctrl-btn" id="btn-prev" title="Previous (←)" aria-label="Previous track">
          <svg width="18" height="18" viewBox="0 -960 960 960" fill="currentColor"><path d="M220-240v-480h80v480h-80Zm520 0L380-480l360-240v480Z"/></svg>
        </button>
        <button class="ctrl-btn play-pause" id="btn-play" title="Play/Pause (Space)" aria-label="Play or pause">
          <svg id="btn-icon-play" width="32" height="32" viewBox="0 -960 960 960" fill="currentColor"><path d="M320-200v-560l440 280-440 280Z"/></svg>
          <svg id="btn-icon-pause" width="32" height="32" viewBox="0 -960 960 960" fill="currentColor" style="display:none"><path d="M560-200v-560h160v560H560Zm-320 0v-560h160v560H240Z"/></svg>
        </button>
        <button class="ctrl-btn" id="btn-next" title="Next (→)" aria-label="Next track">
          <svg height="18" width="18" viewBox="0 -960 960 960" fill="currentColor"><path d="M660-240v-480h80v480h-80Zm-440 0v-480l360 240-360 240Z"/></svg>
        </button>
      </div>

      <!-- Album art -->
      <div class="player-art" id="player-art">♫</div>

      <!-- Track info + progress -->
      <div class="player-track">
        <div class="player-track-title" id="player-title">No track playing</div>
        <div class="player-track-album" id="player-album">—</div>
        <div class="player-progress">
          <div class="progress-bar-wrap" id="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
            <div class="progress-segments" id="progress-segments"></div>
          </div>
          <div class="progress-times">
            <span id="time-cur">0:00</span>
            <span id="time-dur">0:00</span>
          </div>
        </div>
      </div>

      <!-- Ellipsis menu -->
      <div class="menu-anchor" id="menu-anchor">
        <button class="ctrl-btn" id="menu-btn" title="Menu" aria-label="Menu" aria-haspopup="true" aria-expanded="false">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <circle cx="12" cy="5" r="2"/>
            <circle cx="12" cy="12" r="2"/>
            <circle cx="12" cy="19" r="2"/>
          </svg>
        </button>
        <div class="menu-popover" id="menu-popover" role="menu" style="display:none">
          <button class="menu-item" id="menu-pick-dir" role="menuitem">Open Directory</button>
          <button class="menu-item" id="menu-toggle-progress" role="menuitem">Switch Progress Bar Style</button>
          <button class="menu-item" id="menu-appearance" role="menuitem">Appearance Options…</button>
        </div>
      </div>
    </div>

  </div>
</div>

<div id="offline-toast">◎ You're offline — library still available</div>

<!-- Appearance modal -->
<div id="appearance-modal">
  <div class="modal-content">
    <div class="modal-header">
      <span class="modal-header-title">Appearance</span>
      <button class="modal-close" id="modal-close" aria-label="Close">&times;</button>
    </div>
    <div class="modal-body">
      <div class="modal-row">
        <span class="modal-label">Player Accent Color</span>
        <div class="accent-controls">
          <input type="color" class="accent-color-input" id="accent-color-input" value="#eeeeee">
          <input type="text" class="accent-hex-input" id="accent-hex-input" value="#eeeeee" maxlength="7" spellcheck="false">
        </div>
      </div>
      <div class="modal-row">
        <span class="modal-label">Title Font</span>
        <select class="modal-select" id="title-font-select">
          <option value="system-ui, sans-serif">System</option>
          <option value="Google Sans">Google Sans</option>
          <option value="Inter">Inter</option>
          <option value="JetBrains Mono">JetBrains Mono</option>
          <option value="DM Sans">DM Sans</option>
          <option value="IBM Plex Sans">IBM Plex Sans</option>
          <option value="Source Sans 3">Source Sans 3</option>
          <option value="Source Serif 4">Source Serif 4</option>
          <option value="SN Pro">SN Pro</option>
          <option value="Momo Trust Sans">Momo Trust Sans</option>
          <option value="Mozilla Text">Mozilla Text</option>
          <option value="IBM Plex Mono">IBM Plex Mono</option>
          <option value="Atkinson Hyperlegible Next">Atkinson Hyperlegible Next</option>
          <option value="Geist Mono">Geist Mono</option>
          <option value="Geist">Geist</option>
          <option value="Funnel Sans">Funnel Sans</option>
          <option value="Faculty Glyphic">Faculty Glyphic</option>
          <option value="Familjen Grotesk">Familjen Grotesk</option>
        </select>
      </div>
      <div class="modal-row">
        <span class="modal-label">Body Font</span>
        <select class="modal-select" id="body-font-select">
          <option value="system-ui, sans-serif">System</option>
          <option value="Google Sans">Google Sans</option>
          <option value="Inter">Inter</option>
          <option value="JetBrains Mono">JetBrains Mono</option>
          <option value="DM Sans">DM Sans</option>
          <option value="IBM Plex Sans">IBM Plex Sans</option>
          <option value="Source Sans 3">Source Sans 3</option>
          <option value="Source Serif 4">Source Serif 4</option>
          <option value="SN Pro">SN Pro</option>
          <option value="Momo Trust Sans">Momo Trust Sans</option>
          <option value="Mozilla Text">Mozilla Text</option>
          <option value="IBM Plex Mono">IBM Plex Mono</option>
          <option value="Atkinson Hyperlegible Next">Atkinson Hyperlegible Next</option>
          <option value="Geist Mono">Geist Mono</option>
          <option value="Geist">Geist</option>
          <option value="Funnel Sans">Funnel Sans</option>
          <option value="Faculty Glyphic">Faculty Glyphic</option>
          <option value="Familjen Grotesk">Familjen Grotesk</option>
        </select>
      </div>
      <div class="modal-row">
        <span class="modal-label">Font Smoothing</span>
        <label class="toggle">
          <input type="checkbox" id="font-smoothing-toggle">
          <span class="toggle-track"></span>
        </label>
      </div>
    </div>
  </div>
</div>

<audio id="audio-el"></audio>

<script>
'use strict';

// ════════════════════════════════════════════════
// Service Worker registration
// ════════════════════════════════════════════════
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => {
        console.log('[Folder.fm] SW registered:', reg.scope);
        // Prompt user to refresh when new SW is waiting
        reg.addEventListener('updatefound', () => {
          const newWorker = reg.installing;
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New version available — could show a toast here
              newWorker.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        });
      })
      .catch(err => console.warn('[Folder.fm] SW registration failed:', err));
  });
}

// ════════════════════════════════════════════════
// PWA install prompt
// ════════════════════════════════════════════════
let deferredInstallPrompt = null;

window.addEventListener('beforeinstallprompt', e => {
  e.preventDefault();
  deferredInstallPrompt = e;
  document.getElementById('install-banner').style.display = 'flex';
});

document.getElementById('install-btn').addEventListener('click', async () => {
  if (!deferredInstallPrompt) return;
  deferredInstallPrompt.prompt();
  const { outcome } = await deferredInstallPrompt.userChoice;
  deferredInstallPrompt = null;
  document.getElementById('install-banner').style.display = 'none';
});

document.getElementById('dismiss-install').addEventListener('click', () => {
  document.getElementById('install-banner').style.display = 'none';
});

window.addEventListener('appinstalled', () => {
  document.getElementById('install-banner').style.display = 'none';
  deferredInstallPrompt = null;
});

// ════════════════════════════════════════════════
// Offline / online detection
// ════════════════════════════════════════════════
const offlineToast = document.getElementById('offline-toast');

function updateOnlineStatus() {
  if (!navigator.onLine) {
    offlineToast.classList.add('show');
  } else {
    offlineToast.classList.remove('show');
  }
}

window.addEventListener('online',  updateOnlineStatus);
window.addEventListener('offline', updateOnlineStatus);

// ════════════════════════════════════════════════
// App state
// ════════════════════════════════════════════════
let albums = {};
let queue  = [];
let qIdx   = 0;
let currentAlbumKey = null;
let isPlaying = false;

// ── Progress bar mode & album progress state ──
let progressMode = localStorage.getItem('fm-progress-mode') || 'track';
let trackDurations = [];
let totalAlbumDuration = 0;
let durationsReady = false;

// ── Appearance state ──
let accentColor = localStorage.getItem('fm-accent-color') || '#eeeeee';
let titleFont   = localStorage.getItem('fm-title-font')   || 'system-ui, sans-serif';
let bodyFont    = localStorage.getItem('fm-body-font')     || 'system-ui, sans-serif';
let fontSmoothing = localStorage.getItem('fm-font-smoothing') === 'true';

const audioEl  = document.getElementById('audio-el');
const playerEl = document.getElementById('player');
const gridEl   = document.getElementById('albums-grid');
const emptyEl  = document.getElementById('empty-state');
const scanEl   = document.getElementById('scan-state');
const scanCnt  = document.getElementById('scan-count');

// ── Restore preferences immediately ──
{
  // Accent color
  if (accentColor !== '#eeeeee') {
    document.documentElement.style.setProperty('--accent', accentColor);
  }
  // Fonts — apply CSS vars inline; font loading happens after utilities are defined
  if (titleFont !== 'system-ui, sans-serif') {
    document.documentElement.style.setProperty('--font-title', `"${titleFont}", system-ui, sans-serif`);
  }
  if (bodyFont !== 'system-ui, sans-serif') {
    document.documentElement.style.setProperty('--font-body', `"${bodyFont}", system-ui, sans-serif`);
  }
  if (fontSmoothing) {
    document.documentElement.style.setProperty('-webkit-font-smoothing', 'antialiased');
  }
}

// ════════════════════════════════════════════════
// Album progress bar utilities
// ════════════════════════════════════════════════
function discoverDurations(tracks) {
  durationsReady = false;
  trackDurations = new Array(tracks.length).fill(0);
  totalAlbumDuration = 0;

  let resolved = 0;
  return new Promise(resolve => {
    if (tracks.length === 0) { durationsReady = true; resolve(); return; }

    tracks.forEach((t, i) => {
      const tmp = new Audio();
      tmp.preload = 'metadata';
      const url = URL.createObjectURL(t.file);

      const done = () => {
        trackDurations[i] = tmp.duration || 0;
        URL.revokeObjectURL(url);
        tmp.removeAttribute('src');
        tmp.load();
        resolved++;
        if (resolved === tracks.length) {
          totalAlbumDuration = trackDurations.reduce((a, b) => a + b, 0);
          durationsReady = true;
          renderSegments();
          resolve();
        }
      };

      tmp.addEventListener('loadedmetadata', done, { once: true });
      tmp.addEventListener('error', done, { once: true });
      tmp.src = url;
    });
  });
}

function renderSegments() {
  const container = document.getElementById('progress-segments');
  const wrap = document.getElementById('progress-bar');
  container.innerHTML = '';

  if (progressMode !== 'album' || !durationsReady || totalAlbumDuration === 0) {
    wrap.classList.remove('album-mode');
    return;
  }

  wrap.classList.add('album-mode');

  let cumulative = 0;
  for (let i = 0; i < trackDurations.length - 1; i++) {
    cumulative += trackDurations[i];
    const pct = (cumulative / totalAlbumDuration) * 100;
    const div = document.createElement('div');
    div.className = 'segment-divider';
    div.style.left = pct + '%';
    container.appendChild(div);
  }
}

function getAlbumProgress() {
  if (!durationsReady || totalAlbumDuration === 0) return 0;
  let elapsed = 0;
  for (let i = 0; i < qIdx; i++) elapsed += trackDurations[i];
  elapsed += audioEl.currentTime;
  return Math.min(1, elapsed / totalAlbumDuration);
}

function albumSeek(fraction) {
  if (!durationsReady || totalAlbumDuration === 0) return;

  const targetTime = fraction * totalAlbumDuration;
  let cumulative = 0;

  for (let i = 0; i < trackDurations.length; i++) {
    if (cumulative + trackDurations[i] > targetTime || i === trackDurations.length - 1) {
      const offset = targetTime - cumulative;
      if (i !== qIdx) {
        playTrack(i);
        audioEl.addEventListener('loadedmetadata', () => {
          audioEl.currentTime = Math.min(offset, audioEl.duration);
        }, { once: true });
      } else {
        audioEl.currentTime = Math.min(offset, audioEl.duration);
      }
      return;
    }
    cumulative += trackDurations[i];
  }
}

function updateProgress() {
  if (!audioEl.duration) return;

  let pct;
  if (progressMode === 'album' && durationsReady && totalAlbumDuration > 0) {
    pct = getAlbumProgress() * 100;
  } else {
    pct = (audioEl.currentTime / audioEl.duration) * 100;
  }

  document.getElementById('progress-fill').style.width = pct + '%';
  document.getElementById('time-cur').textContent = fmt(audioEl.currentTime);
  document.getElementById('time-dur').textContent = fmt(audioEl.duration);
}

// ════════════════════════════════════════════════
// Appearance utilities
// ════════════════════════════════════════════════
const loadedFonts = new Set();

function loadGoogleFont(fontName) {
  if (fontName === 'system-ui, sans-serif' || loadedFonts.has(fontName)) return;
  loadedFonts.add(fontName);
  const encoded = encodeURIComponent(fontName);
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?family=${encoded}:wght@400;500;600;700&display=swap`;
  document.head.appendChild(link);
}

function applyAccentColor(hex) {
  accentColor = hex;
  document.documentElement.style.setProperty('--accent', hex);
  document.getElementById('accent-color-input').value = hex;
  document.getElementById('accent-hex-input').value = hex;
  localStorage.setItem('fm-accent-color', hex);
}

function applyFont(type, fontValue) {
  loadGoogleFont(fontValue);
  const stack = fontValue === 'system-ui, sans-serif' ? fontValue : `"${fontValue}", system-ui, sans-serif`;
  if (type === 'title') {
    titleFont = fontValue;
    document.documentElement.style.setProperty('--font-title', stack);
    localStorage.setItem('fm-title-font', fontValue);
  } else {
    bodyFont = fontValue;
    document.documentElement.style.setProperty('--font-body', stack);
    localStorage.setItem('fm-body-font', fontValue);
  }
}

// Load stored Google Fonts (now that loadGoogleFont is defined)
loadGoogleFont(titleFont);
loadGoogleFont(bodyFont);

// ════════════════════════════════════════════════
// Directory persistence (IndexedDB)
// ════════════════════════════════════════════════
// FileSystemDirectoryHandle objects are serializable via structured clone,
// so they can be stored in IndexedDB and restored across sessions. On reload
// we check queryPermission() — if already granted we auto-scan; if not we
// show a one-tap prompt that calls requestPermission() before scanning.
const DB_NAME  = 'folder-fm-db';
const DB_STORE = 'handles';
const DB_KEY   = 'last-dir';

function openDb() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => e.target.result.createObjectStore(DB_STORE);
    req.onsuccess = e => resolve(e.target.result);
    req.onerror   = e => reject(e.target.error);
  });
}

async function saveDirHandle(handle) {
  try {
    const db = await openDb();
    const tx = db.transaction(DB_STORE, 'readwrite');
    tx.objectStore(DB_STORE).put(handle, DB_KEY);
  } catch(e) {}
}

async function loadDirHandle() {
  try {
    const db = await openDb();
    return await new Promise((resolve, reject) => {
      const tx  = db.transaction(DB_STORE, 'readonly');
      const req = tx.objectStore(DB_STORE).get(DB_KEY);
      req.onsuccess = e => resolve(e.target.result || null);
      req.onerror   = e => reject(e.target.error);
    });
  } catch(e) { return null; }
}

// ════════════════════════════════════════════════
// Open folder
// ════════════════════════════════════════════════
async function openFolder() {
  if (!window.showDirectoryPicker) {
    alert('Your browser does not support the File System Access API.\nPlease use Chrome or Edge (desktop).');
    return;
  }
  let dirHandle;
  try { dirHandle = await window.showDirectoryPicker({ mode: 'read' }); }
  catch(e) { return; } // user cancelled

  // Save handle for next session
  saveDirHandle(dirHandle);

  albums = {};
  gridEl.innerHTML = '';
  gridEl.style.display = 'none';
  emptyEl.style.display = 'none';
  scanEl.style.display = 'flex';
  scanCnt.textContent = '0';

  // Show idle player while scanning
  playerEl.classList.add('idle');

  await scanDir(dirHandle);
  renderAlbums();
}

document.getElementById('pick-dir-btn').addEventListener('click', openFolder);

// ════════════════════════════════════════════════
// Ellipsis menu
// ════════════════════════════════════════════════
const menuBtn     = document.getElementById('menu-btn');
const menuPopover = document.getElementById('menu-popover');

function toggleMenu() {
  const open = menuPopover.style.display === 'none';
  menuPopover.style.display = open ? 'block' : 'none';
  menuBtn.setAttribute('aria-expanded', open);
}

function closeMenu() {
  menuPopover.style.display = 'none';
  menuBtn.setAttribute('aria-expanded', 'false');
}

menuBtn.addEventListener('click', e => { e.stopPropagation(); toggleMenu(); });

document.addEventListener('click', e => {
  if (!menuPopover.contains(e.target) && e.target !== menuBtn) closeMenu();
});

document.getElementById('menu-pick-dir').addEventListener('click', () => {
  closeMenu();
  openFolder();
});

document.getElementById('menu-toggle-progress').addEventListener('click', () => {
  progressMode = progressMode === 'track' ? 'album' : 'track';
  localStorage.setItem('fm-progress-mode', progressMode);
  renderSegments();
  updateProgress();
  closeMenu();
});

document.getElementById('menu-appearance').addEventListener('click', () => {
  closeMenu();
  openAppearanceModal();
});

// ════════════════════════════════════════════════
// Appearance modal
// ════════════════════════════════════════════════
const appearanceModal = document.getElementById('appearance-modal');

function openAppearanceModal() {
  // Sync inputs to current state
  document.getElementById('accent-color-input').value = accentColor;
  document.getElementById('accent-hex-input').value = accentColor;
  document.getElementById('title-font-select').value = titleFont;
  document.getElementById('body-font-select').value = bodyFont;
  document.getElementById('font-smoothing-toggle').checked = fontSmoothing;
  appearanceModal.classList.add('open');
}

function closeAppearanceModal() {
  appearanceModal.classList.remove('open');
}

document.getElementById('modal-close').addEventListener('click', closeAppearanceModal);

appearanceModal.addEventListener('click', e => {
  if (e.target === appearanceModal) closeAppearanceModal();
});

// Accent color: color picker
document.getElementById('accent-color-input').addEventListener('input', e => {
  applyAccentColor(e.target.value);
});

// Accent color: hex text input
document.getElementById('accent-hex-input').addEventListener('input', e => {
  const val = e.target.value;
  if (/^#[0-9a-fA-F]{6}$/.test(val)) {
    applyAccentColor(val);
  }
});

// Font selects
document.getElementById('title-font-select').addEventListener('change', e => {
  applyFont('title', e.target.value);
});

document.getElementById('body-font-select').addEventListener('change', e => {
  applyFont('body', e.target.value);
});

// Font smoothing toggle
document.getElementById('font-smoothing-toggle').addEventListener('change', e => {
  fontSmoothing = e.target.checked;
  document.documentElement.style.setProperty('-webkit-font-smoothing',
    fontSmoothing ? 'antialiased' : 'subpixel-antialiased');
  localStorage.setItem('fm-font-smoothing', fontSmoothing);
});

// ════════════════════════════════════════════════
// On load: restore saved directory handle if available
// ════════════════════════════════════════════════
window.addEventListener('load', async () => {
  const handle = await loadDirHandle();
  if (!handle) return;

  const perm = await handle.queryPermission({ mode: 'read' });

  if (perm === 'granted') {
    // Permission already granted — auto-scan without any user interaction
    scanEl.style.display = 'flex';
    emptyEl.style.display = 'none';
    scanCnt.textContent = '0';
    playerEl.classList.add('idle');
    await scanDir(handle);
    renderAlbums();
  } else {
    // Need a user gesture to re-grant — show a one-tap reload button
    const subEl = document.querySelector('.empty-sub');
    if (subEl) subEl.innerHTML =
      `Last opened: <strong>${handle.name}</strong>. ` +
      `<button id="reload-dir-btn" class="text-btn">Reload library</button>`;
    document.getElementById('reload-dir-btn')?.addEventListener('click', async () => {
      const granted = await handle.requestPermission({ mode: 'read' });
      if (granted !== 'granted') return;
      emptyEl.style.display = 'none';
      scanEl.style.display = 'flex';
      scanCnt.textContent = '0';
      playerEl.classList.add('idle');
      await scanDir(handle);
      renderAlbums();
    });
  }
});

// ════════════════════════════════════════════════
// Recursive directory scan
// ════════════════════════════════════════════════
async function scanDir(dirHandle) {
  for await (const entry of dirHandle.values()) {
    if (entry.kind === 'directory') {
      await scanDir(entry);
    } else if (entry.kind === 'file') {
      const name = entry.name.toLowerCase();
      if (name.endsWith('.mp3') || name.endsWith('.flac') || name.endsWith('.m4a') ||
          name.endsWith('.ogg') || name.endsWith('.wav')  || name.endsWith('.aac')) {
        const file = await entry.getFile();
        await processTrack(file);
        scanCnt.textContent = Object.values(albums).reduce((a,b) => a + b.tracks.length, 0);
      }
    }
  }
}

// ════════════════════════════════════════════════
// Tag extraction & album grouping
// ════════════════════════════════════════════════
function processTrack(file) {
  return new Promise(resolve => {
    jsmediatags.read(file, {
      onSuccess(tag) {
        const t      = tag.tags;
        const artist = t.artist || 'Unknown Artist';
        const album  = t.album  || 'Unknown Album';
        const title  = t.title  || file.name;
        const track  = parseInt(t.track) || 999;
        const key    = `${artist} — ${album}`;

        if (!albums[key]) albums[key] = { artist, album, tracks: [], art: null };
        albums[key].tracks.push({ file, title, track });

        if (!albums[key].art && t.picture) {
          const pic  = t.picture;
          const blob = new Blob([new Uint8Array(pic.data)], { type: pic.format });
          albums[key].art = URL.createObjectURL(blob);
        }
        resolve();
      },
      onError() {
        const key = 'Unknown Artist — Unknown Album';
        if (!albums[key]) albums[key] = { artist:'Unknown Artist', album:'Unknown Album', tracks:[], art:null };
        albums[key].tracks.push({ file, title: file.name, track: 999 });
        resolve();
      }
    });
  });
}

// ════════════════════════════════════════════════
// Render album grid
// ════════════════════════════════════════════════
function renderAlbums() {
  scanEl.style.display = 'none';
  gridEl.innerHTML = '';

  const sorted = Object.entries(albums).sort(([,a],[,b]) =>
    `${a.artist}${a.album}`.localeCompare(`${b.artist}${b.album}`));

  if (!sorted.length) {
    emptyEl.style.display = 'flex';
    return;
  }

  gridEl.style.display = 'grid';

  sorted.forEach(([key, data], i) => {
    data.tracks.sort((a,b) => a.track - b.track);

    const card = document.createElement('div');
    card.className = 'album-card';
    card.dataset.key = key;
    card.style.animationDelay = `${Math.min(i * 30, 600)}ms`;
    card.setAttribute('role', 'button');
    card.setAttribute('aria-label', `Play ${data.album} by ${data.artist}`);
    card.setAttribute('tabindex', '0');

    card.innerHTML = `
      <div class="album-art-wrap">
        ${data.art
          ? `<img src="${data.art}" alt="${esc(data.album)}" loading="lazy">`
          : `<div class="no-art">◉</div>`}
        <div class="album-overlay">
          <div class="play-icon">
            <span class="play-icon-svg"><svg id="icon-play" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor"><path d="M320-200v-560l440 280-440 280Z"/></svg></span>
            <span class="playing-indicator" aria-hidden="true">
              <span class="bar"></span>
              <span class="bar"></span>
              <span class="bar"></span>
              <span class="bar"></span>
            </span>
          </div>
        </div>
      </div>
      <div class="album-info">
        <div class="album-title">${esc(data.album)}</div>
        <div class="album-artist">${esc(data.artist)}</div>
      </div>
    `;

    card.addEventListener('click', () => playAlbum(key, data));
    card.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); playAlbum(key, data); }
    });
    gridEl.appendChild(card);
  });
}

function esc(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// ════════════════════════════════════════════════
// Playback
// ════════════════════════════════════════════════
function playAlbum(key, data) {
  document.querySelectorAll('.album-card').forEach(c => c.classList.remove('playing'));
  document.querySelector(`.album-card[data-key="${CSS.escape(key)}"]`)?.classList.add('playing');

  currentAlbumKey = key;
  queue = data.tracks;
  qIdx  = 0;

  const artEl = document.getElementById('player-art');
  artEl.innerHTML = data.art
    ? `<img src="${data.art}" alt="">`
    : '♫';

  // Discover track durations for album progress mode (non-blocking)
  discoverDurations(data.tracks);

  playTrack(0);
}

function playTrack(idx) {
  if (idx < 0 || idx >= queue.length) return;
  qIdx = idx;
  const t = queue[idx];

  // Suppress progress bar transition during track switch in album mode
  if (progressMode === 'album') {
    const fillEl = document.getElementById('progress-fill');
    fillEl.style.transition = 'none';
    requestAnimationFrame(() => {
      requestAnimationFrame(() => { fillEl.style.transition = 'width 0.3s linear'; });
    });
  }

  audioEl.src = URL.createObjectURL(t.file);
  audioEl.play().catch(console.warn);

  const title     = t.title;
  const albumData = albums[currentAlbumKey];
  const albumStr  = albumData ? `${albumData.album} · ${albumData.artist}` : '';

  document.getElementById('player-title').textContent = title;
  document.getElementById('player-album').textContent = albumStr;
  setPlayState(true);

  // Remove idle dimming — library is loaded and something is playing
  playerEl.classList.remove('idle');

  // Media Session API — lock screen / notification controls
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title,
      artist: albumData?.artist || '',
      album:  albumData?.album  || '',
      artwork: albumData?.art
        ? [{ src: albumData.art, sizes: '512x512' }]
        : []
    });

    navigator.mediaSession.setActionHandler('play',          () => { audioEl.play();  setPlayState(true);  });
    navigator.mediaSession.setActionHandler('pause',         () => { audioEl.pause(); setPlayState(false); });
    navigator.mediaSession.setActionHandler('previoustrack', () => {
      if (audioEl.currentTime > 3) audioEl.currentTime = 0;
      else playTrack(qIdx - 1);
    });
    navigator.mediaSession.setActionHandler('nexttrack',     () => playTrack(qIdx + 1));
    navigator.mediaSession.setActionHandler('seekto', details => {
      if (details.seekTime !== undefined) audioEl.currentTime = details.seekTime;
    });
  }
}

audioEl.addEventListener('ended', () => {
  if (qIdx + 1 < queue.length) playTrack(qIdx + 1);
  else {
    setPlayState(false);
    // Remove playing indicator but keep playing card highlighted
    document.querySelectorAll('.album-card.playing').forEach(c => c.classList.add('paused'));
  }
});

audioEl.addEventListener('timeupdate', () => {
  updateProgress();

  // Update Media Session position state
  if ('mediaSession' in navigator && navigator.mediaSession.setPositionState && audioEl.duration) {
    navigator.mediaSession.setPositionState({
      duration:     audioEl.duration,
      playbackRate: audioEl.playbackRate,
      position:     audioEl.currentTime
    });
  }
});

// Progress bar click + drag
const progressBar = document.getElementById('progress-bar');

function seek(e) {
  const rect = progressBar.getBoundingClientRect();
  const x    = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
  const fraction = Math.max(0, Math.min(1, x / rect.width));

  if (progressMode === 'album' && durationsReady && totalAlbumDuration > 0) {
    albumSeek(fraction);
  } else {
    if (!audioEl.duration) return;
    audioEl.currentTime = fraction * audioEl.duration;
  }
}

progressBar.addEventListener('click',      seek);
progressBar.addEventListener('touchstart', seek, { passive: true });

let dragging = false;
progressBar.addEventListener('mousedown', () => { dragging = true; });
window.addEventListener('mousemove',  e => { if (dragging) seek(e); });
window.addEventListener('mouseup',   () => { dragging = false; });

// Controls
document.getElementById('btn-play').addEventListener('click', () => {
  if (audioEl.paused) { audioEl.play();  setPlayState(true);  }
  else                { audioEl.pause(); setPlayState(false); }
});

document.getElementById('btn-prev').addEventListener('click', () => {
  if (audioEl.currentTime > 3) audioEl.currentTime = 0;
  else playTrack(qIdx - 1);
});

document.getElementById('btn-next').addEventListener('click', () => playTrack(qIdx + 1));

function setPlayState(playing) {
  isPlaying = playing;
  document.getElementById('btn-icon-play').style.display  = playing ? 'none'  : 'block';
  document.getElementById('btn-icon-pause').style.display = playing ? 'block' : 'none';

  // Pause/resume EQ animation on playing card
  document.querySelectorAll('.album-card.playing').forEach(c => {
    c.classList.toggle('paused', !playing);
  });

  if ('mediaSession' in navigator) {
    navigator.mediaSession.playbackState = playing ? 'playing' : 'paused';
  }
}

function fmt(s) {
  const m   = Math.floor(s / 60);
  const sec = Math.floor(s % 60).toString().padStart(2, '0');
  return `${m}:${sec}`;
}

// ════════════════════════════════════════════════
// Keyboard shortcuts
// ════════════════════════════════════════════════
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') { closeMenu(); closeAppearanceModal(); return; }
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
  if (e.code === 'Space')      { e.preventDefault(); document.getElementById('btn-play').click(); }
  if (e.code === 'ArrowRight') { e.preventDefault(); document.getElementById('btn-next').click(); }
  if (e.code === 'ArrowLeft')  { e.preventDefault(); document.getElementById('btn-prev').click(); }
});

// ════════════════════════════════════════════════
// Wake Lock (prevent screen sleep while playing)
// ════════════════════════════════════════════════
let wakeLock = null;

async function requestWakeLock() {
  if ('wakeLock' in navigator && isPlaying) {
    try { wakeLock = await navigator.wakeLock.request('screen'); }
    catch(e) { /* not critical */ }
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && isPlaying) requestWakeLock();
});

audioEl.addEventListener('play',  requestWakeLock);
audioEl.addEventListener('pause', () => { wakeLock?.release(); wakeLock = null; });
</script>
</body>
</html>